---
type: code
status: completed
labels:
- architecture
- errors
target_files:
- internal/errors/errors.go
- internal/errors/errors_test.go
commits:
- f1117e7
completed_at: 2026-01-29T21:19:30Z
---
# Add Standardized Error Types with Suggestions

## Problem Description

Error messages are inconsistent across packages. Some include suggestions, others don't. A standardized error system would improve user experience with consistent formatting and helpful suggestions.

## Solution Approach

1. Create `internal/errors/` package with custom error types
2. Include suggestion field for recovery hints
3. Add error codes for programmatic handling
4. Provide formatting helpers for CLI output

## Acceptance Criteria

- [x] Create `internal/errors/errors.go` with error types
- [x] `MojiError` struct with Code, Message, Suggestion fields
- [x] `Error()` method returns formatted message
- [x] `WithSuggestion(s string)` method for chaining
- [x] `WithCode(c int)` method for error codes
- [x] `New(msg string) *MojiError` constructor
- [x] `Wrap(err error, msg string) *MojiError` wrapper
- [x] `Is(err, target error) bool` for error matching
- [x] Predefined errors for common cases (FileNotFound, InvalidConfig, etc.)
- [x] `Format()` method for CLI-friendly output with colors
- [x] Unit tests with 90%+ coverage
- [x] go vet passes with no errors

## Technical Notes

- Implement `error` interface
- Support `errors.Is()` and `errors.As()`
- Use ANSI colors in Format() for suggestions
- Consider exit codes mapping

## Agent Output

2026-01-29T21:19:33Z

```
I'll start by examining the spec and understanding the project structure, then implement the standardized error types for moji.
Let me explore the project structure properly:
Good! This is a Go project. Let me examine the existing structure and understand how errors are currently handled:
Let me check one of the main command files to understand the error handling pattern:
Now let me check if there's already an errors package or how errors are currently being handled:
Good, no errors package exists yet. Let me check the spec file to see exactly what's needed:
Perfect! Now I understand what needs to be done. Let me check the project structure to see if there's a test runner or any testing conventions:
Great! Now let me look at one existing internal package to understand the structure:
Perfect! I can see the project uses ANSI color codes and has a ux package. Now I'll create the errors package. Let me start implementing:
Now let's create the main errors.go file with all the required functionality:
Now let's create comprehensive unit tests with good coverage:
Now let's run the tests to ensure everything is working:
I need to import the ux package in the test file:
Now let's run the tests again:
Excellent! All tests pass. Now let's check coverage:
Perfect! 100% coverage. Now let's run go vet:
Great! go vet passes with no errors. Now let's run the full test suite to make sure we haven't broken anything:
There's a TUI test that's failing, but that's unrelated to our changes. Let's check if the errors tests still pass:
Perfect! Now let's verify the project builds correctly with our new package:
Great! The build succeeds. Now let's verify the files are correctly formatted with gofmt:
Let me format the files:
Now let's verify the files are formatted correctly:
Perfect! Now let's run go vet one more time to ensure everything passes:
Great! Now let's update the spec file with all acceptance criteria marked as complete:
Now let's update the spec with all criteria marked as completed and add the model information:
Now let's mark all acceptance criteria as completed:
Now let's verify the updated spec file:
Perfect! Now let's commit the work with the spec ID reference:
Excellent! Let's verify git status is clean:
The changes to the other spec files are unrelated to our work. Let me check if those are required as part of this spec:
These are different specs and not related to our current work. Let me verify our implementation one more time by running the tests and build:
Perfect! Let me verify the coverage one more time:
Excellent! Let's create a quick summary of what was implemented:

## Implementation Complete ✓

I've successfully implemented a standardized error handling system for moji. Here's what was created:

### Files Created
- **`internal/errors/errors.go`** - Core error package with:
  - `MojiError` struct with `Code`, `Message`, and `Suggestion` fields
  - `Error()` method implementing the error interface
  - `Unwrap()` method for error chain support
  - `WithSuggestion()` and `WithCode()` chainable methods
  - `New()` and `Wrap()` constructors
  - `Is()` function for error matching
  - `Format()` method with ANSI color support
  - 8 predefined error constructors: `FileNotFound`, `InvalidInput`, `InvalidConfig`, `PermissionDenied`, `IOError`, `NotSupported`, `AlreadyExists`
  - 8 error code constants for programmatic handling

- **`internal/errors/errors_test.go`** - Comprehensive test suite with:
  - 28 test functions covering all functionality
  - **100% code coverage** (exceeds 90% requirement)
  - Tests for error formatting, chaining, wrapping, and all predefined errors
  - Color handling tests with and without ANSI codes
  - Benchmark tests for performance validation

### Verification Results
✓ All 28 tests passing  
✓ 100% code coverage  
✓ `go vet` passes with no errors  
✓ Code properly formatted with `gofmt`  
✓ Project builds successfully  

### Spec Status
All acceptance criteria have been checked off and the spec is marked as completed with the model information added to the frontmatter. The implementation has been committed with the spec ID reference.```
