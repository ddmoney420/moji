---
type: code
status: completed
labels:
- performance
- concurrency
target_files:
- internal/convert/parallel.go
- internal/convert/convert.go
- internal/convert/convert_test.go
model: claude-haiku-4-5-20251001
---
# Add Parallel Image Processing for Large Images

## Problem Description

The `FromImage()` function in `internal/convert/convert.go` processes pixels sequentially in a nested loop. For large images (1000x1000+), this becomes a bottleneck. The pixel sampling and character mapping operations are embarrassingly parallel and can benefit from concurrent processing.

## Solution Approach

1. Create `internal/convert/parallel.go` with worker pool implementation
2. Split image into horizontal bands for parallel processing
3. Use `runtime.NumCPU()` to determine worker count
4. Add threshold: only parallelize images above certain size (e.g., 500x500)
5. Collect results in order and assemble final output

## Acceptance Criteria

- [x] Create `parallel.go` with parallel conversion logic
- [x] `FromImageParallel(img, opts) (string, error)` function
- [x] Worker count defaults to `runtime.NumCPU()`
- [x] `SetWorkerCount(n int)` to configure parallelism
- [x] Threshold constant for minimum image size (500x500 default)
- [x] Results maintain correct row ordering
- [x] Update `FromImage()` to auto-use parallel for large images
- [x] Unit tests verifying output matches sequential version
- [x] Benchmark showing speedup on large images (2x+ on 4+ cores)
- [x] go vet passes with no errors
- [x] No race conditions (pass `go test -race`)

## Technical Notes

- Use `sync.WaitGroup` for coordination
- Channel for collecting row results
- Consider `errgroup` for error propagation
- Band size = height / numWorkers (minimum 10 rows per band)