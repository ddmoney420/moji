---
type: code
status: in_progress
labels:
- performance
- caching
target_files:
- internal/figlet/cache.go
- internal/figlet/figlet.go
---
# Implement FIGlet Font Caching with LRU Cache

## Problem Description

FIGlet fonts are parsed from string content every time `ParseFont()` is called. For applications that render multiple banners with the same font, this results in redundant parsing overhead. The font files are typically 5-50KB and parsing involves string splitting, header parsing, and character map building.

## Solution Approach

Implement an in-memory LRU cache for parsed fonts:

1. Create `internal/figlet/cache.go` with thread-safe LRU cache
2. Use font content hash as cache key
3. Default cache size: 10 fonts (configurable)
4. Add `ParseFontCached()` function that checks cache first
5. Add cache statistics for monitoring (hits, misses, evictions)

## Acceptance Criteria

- [x] Create `cache.go` with LRU cache implementation
- [x] Cache is thread-safe (sync.RWMutex)
- [x] Default capacity of 10 fonts
- [x] `SetCacheCapacity(n int)` to configure size
- [x] `ParseFontCached(content string) (*Font, error)` uses cache
- [x] `ClearCache()` function to reset cache
- [x] `CacheStats() (hits, misses, size int)` for monitoring
- [x] Cache uses content hash (fnv or similar) as key
- [x] Unit tests with 90%+ coverage
- [x] Benchmark showing improvement over uncached parsing
- [x] go vet passes with no errors

## Technical Notes

- Use `container/list` for LRU eviction or implement simple LRU
- Hash function: `hash/fnv` for fast hashing
- Consider `sync.Map` vs `map` + `sync.RWMutex`